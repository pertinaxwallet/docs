"use strict";(self.webpackChunkeverscale_docs_website=self.webpackChunkeverscale_docs_website||[]).push([[2177],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return m}});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var d=r.createContext({}),l=function(e){var t=r.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=l(e.components);return r.createElement(d.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,d=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=l(n),m=a,h=u["".concat(d,".").concat(m)]||u[m]||c[m]||o;return n?r.createElement(h,i(i({ref:t},p),{},{components:n})):r.createElement(h,i({ref:t},p))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=u;var s={};for(var d in t)hasOwnProperty.call(t,d)&&(s[d]=t[d]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var l=2;l<o;l++)i[l]=n[l];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}u.displayName="MDXCreateElement"},202:function(e,t,n){n.r(t),n.d(t,{assets:function(){return p},contentTitle:function(){return d},default:function(){return m},frontMatter:function(){return s},metadata:function(){return l},toc:function(){return c}});var r=n(3117),a=n(102),o=(n(7294),n(3905)),i=["components"],s={title:"1. Web3 provider javascript API",sidebar_position:1},d=void 0,l={unversionedId:"Standard/TIP-32/1",id:"Standard/TIP-32/1",title:"1. Web3 provider javascript API",description:"Abstract",source:"@site/../../src/Standard/TIP-32/1.md",sourceDirName:"Standard/TIP-32",slug:"/Standard/TIP-32/1",permalink:"/Standard/TIP-32/1",draft:!1,editUrl:"https://github.com/everscale-org/docs/edit/main/.build/website/../../src/Standard/TIP-32/1.md",tags:[],version:"current",lastUpdatedAt:1658794573,formattedLastUpdatedAt:"Jul 26, 2022",sidebarPosition:1,frontMatter:{title:"1. Web3 provider javascript API",sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Core description",permalink:"/Standard/TIP-32/core-description"},next:{title:"Network Changelog",permalink:"/changelog"}},p={},c=[{value:"Abstract",id:"abstract",level:2},{value:"Motivation",id:"motivation",level:2},{value:"Specification",id:"specification",level:2},{value:"Glossary",id:"glossary",level:3},{value:"Interface",id:"interface",level:3},{value:"Request",id:"request",level:4},{value:"Supported RPC Methods",id:"supported-rpc-methods",level:4},{value:"RPC Errors",id:"rpc-errors",level:4},{value:"Error Standards",id:"error-standards",level:4},{value:"Provider Errors",id:"provider-errors",level:4},{value:"Subscriptions",id:"subscriptions",level:4},{value:"Events",id:"events",level:4},{value:"message",id:"message",level:5},{value:"connect",id:"connect",level:5},{value:"disconnect",id:"disconnect",level:5},{value:"endpointChanged",id:"endpointchanged",level:5},{value:"accountChanged",id:"accountchanged",level:5},{value:"Rationale",id:"rationale",level:4},{value:"Security Considerations",id:"security-considerations",level:4},{value:"Handling Adversarial Behavior",id:"handling-adversarial-behavior",level:4},{value:"Endpoint Changes",id:"endpoint-changes",level:4},{value:"User Account Exposure and Account Changes",id:"user-account-exposure-and-account-changes",level:4},{value:"Copyright",id:"copyright",level:4},{value:"Appendix I: Used function names",id:"appendix-i-used-function-names",level:4},{value:"Appendix II: Consumer-Facing API Documentation",id:"appendix-ii-consumer-facing-api-documentation",level:4},{value:"Request",id:"request-1",level:5},{value:"Events",id:"events-1",level:5},{value:"connect",id:"connect-1",level:6},{value:"disconnect",id:"disconnect-1",level:6},{value:"endpointChanged",id:"endpointchanged-1",level:6},{value:"accountChanged",id:"accountchanged-1",level:6},{value:"unlockStateChanged",id:"unlockstatechanged",level:6},{value:"message",id:"message-1",level:6},{value:"Subscriptions",id:"subscriptions-1",level:5},{value:"Errors",id:"errors",level:5},{value:"Appendix III: Examples",id:"appendix-iii-examples",level:5}],u={toc:c};function m(e){var t=e.components,n=(0,a.Z)(e,i);return(0,o.kt)("wrapper",(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h2",{id:"abstract"},"Abstract"),(0,o.kt)("p",null,"A common convention in the EVERSCALE web application (\u201cDApp\u201d) ecosystem is for key management software (\u201cwallets\u201d) to expose their API via a JavaScript object in the web page. This object is called \u201cthe Provider\u201d.",(0,o.kt)("br",{parentName:"p"}),"\n","The Provider implementations can have conflicting interfaces and behaviors between wallets. This TIP formalizes an EVERSCALE Provider API to promote wallet interoperability. The API is designed to be minimal, event-driven, and agnostic of transport. Its functionality is easily extended by defining new methods and message event types.",(0,o.kt)("br",{parentName:"p"}),"\n","Offer for all providers to make available their features as window.everscale in web browsers for uniformity."),(0,o.kt)("h2",{id:"motivation"},"Motivation"),(0,o.kt)("p",null,"Many teams have created their own solutions during recently conducted the ",(0,o.kt)("a",{parentName:"p",href:"https://forum.freeton.org/t/contest-proposal-free-ton-wallet-as-a-chrome-extension/8677/36"},"1st round of Contest on TON wallet as Chrome web extension"),". This proposal sets as the main aim to work out an agreement for the Web3 like provider interface to avoid any artificial situation when DApp developers can be forced to use only the one wallet on the market. Offer to introduce the uniform Web3 like provider interface and implement its on 3rd stage the contest to allow users using any wallet solution for decentralized applications (DApp) interaction aims."),(0,o.kt)("h2",{id:"specification"},"Specification"),(0,o.kt)("p",null,"The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC-2119.",(0,o.kt)("br",{parentName:"p"}),"\n","The Provider API is specified using TypeScript.",(0,o.kt)("br",{parentName:"p"}),"\n","The Provider MUST implement and expose the API defined in this section. All API entities MUST adhere to the types and interfaces defined in this section."),(0,o.kt)("h3",{id:"glossary"},"Glossary"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Provider")," - A JavaScript object made available to a consumer, that provides access to EVERSCALE blockchain by means of a Client.",(0,o.kt)("br",{parentName:"p"}),"\n",(0,o.kt)("strong",{parentName:"p"},"Client")," - An endpoint that receives requests from the Provider, and returns their results.",(0,o.kt)("br",{parentName:"p"}),"\n",(0,o.kt)("strong",{parentName:"p"},"Wallet")," - An end-user application that manages private keys, performs signing operations, and acts as a middleware between the Provider and the Client.",(0,o.kt)("br",{parentName:"p"}),"\n",(0,o.kt)("strong",{parentName:"p"},"Remote Procedure Call (RPC)")," - A Remote Procedure Call (RPC), is any request submitted to a Provider for some procedure that is to be processed by a Provider, its Wallet, or its Client.",(0,o.kt)("br",{parentName:"p"}),"\n",(0,o.kt)("strong",{parentName:"p"},"Connected provider")," - The situation when it can service RPC requests to at least one endpoint.",(0,o.kt)("br",{parentName:"p"}),"\n",(0,o.kt)("strong",{parentName:"p"},"Disconnected provider")," - The situation when it cannot service RPC requests to at least one endpoint."),(0,o.kt)("h3",{id:"interface"},"Interface"),(0,o.kt)("h4",{id:"request"},"Request"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"interface RequestArguments {\n  readonly method: string;\n  readonly params?: readonly unknown[] | object;\n}\nProvider.request(args: RequestArguments): Promise<unknown>;\n")),(0,o.kt)("p",null,"The Provider must identify the requested RPC method by the value of ",(0,o.kt)("em",{parentName:"p"},"RequestArguments.method"),". This method name MUST adhere the format \u201cprefix_moduleName_functionName\u201d, where prefix always MUST be ",(0,o.kt)("em",{parentName:"p"},"ever"),", ",(0,o.kt)("em",{parentName:"p"},"moduleName")," is a name of module from the documentation ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/tonlabs/TON-SDK/blob/master/docs/reference/types-and-methods/modules.md"},"https://github.com/tonlabs/TON-SDK/blob/master/docs/reference/types-and-methods/modules.md")," and ",(0,o.kt)("em",{parentName:"p"},"functionName")," is a name of function from the the documentation. For example: \u201cever_net_query\u201d ",(0,o.kt)("em",{parentName:"p"},"RequestArguments.method")," will link on the query function from the ",(0,o.kt)("em",{parentName:"p"},"net")," module ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/tonlabs/TON-SDK/blob/master/docs/reference/types-and-methods/mod_net.md#query"},"https://github.com/tonlabs/TON-SDK/blob/master/docs/reference/types-and-methods/mod_net.md#query"),(0,o.kt)("br",{parentName:"p"}),"\n","If the requested RPC method takes any parameters, the Provider MUST accept them as the value of ",(0,o.kt)("em",{parentName:"p"},"RequestArguments.params"),".",(0,o.kt)("br",{parentName:"p"}),"\n","RPC requests MUST be handled such that the returned Promise either resolves with a value per the requested RPC method\u2019s specification, or rejects with an error.",(0,o.kt)("br",{parentName:"p"}),"\n","If resolved, the Promise MUST resolve with a result per the RPC method\u2019s specification. The Promise MUST NOT resolve with any RPC protocol-specific response objects, unless the RPC method\u2019s return type is so defined.",(0,o.kt)("br",{parentName:"p"}),"\n","If the returned Promise rejects, it MUST reject with a ",(0,o.kt)("em",{parentName:"p"},"ProviderRpcError")," as specified in the RPC Errors section below.",(0,o.kt)("br",{parentName:"p"}),"\n","The returned Promise MUST reject if any of the following conditions are met:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"An error is returned for the RPC request.",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"If the returned error is compatible with the ProviderRpcError interface, the Promise MAY reject that error directly."))),(0,o.kt)("li",{parentName:"ul"},"The Provider encounters an error or fails to process the request for any reason.\nThe returned Promise SHOULD reject if any of the following conditions are met:"),(0,o.kt)("li",{parentName:"ul"},"The disconnected provider.",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"If rejected for this reason, the Promise rejection error code MUST be 4900.")))),(0,o.kt)("h4",{id:"supported-rpc-methods"},"Supported RPC Methods"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"interface ProviderRpcResult {\n  code: number;\n  data: unknown;\n}\n")),(0,o.kt)("p",null,"A \u201csupported RPC method\u201d is any RPC method that may be called via the Provider.",(0,o.kt)("br",{parentName:"p"}),"\n","All supported RPC methods MUST be identified by unique strings.",(0,o.kt)("br",{parentName:"p"}),"\n","Providers MAY support whatever RPC methods required to fulfill their purpose, standardized or otherwise.",(0,o.kt)("br",{parentName:"p"}),"\n","As was described above all methods that are included in the standard SDK MUST adhere to the format \u201cprefix_moduleName_functionName\u201d. All other methods are RECOMMENDED to name in the format \u201cprefix_functionName\u201d, where \u201cprefix\u201d MUST be always ",(0,o.kt)("em",{parentName:"p"},"ever")," and ",(0,o.kt)("em",{parentName:"p"},"functionName")," must be string in camelCase naming convention. For example: ",(0,o.kt)("em",{parentName:"p"},"ever_subscribe"),", ",(0,o.kt)("em",{parentName:"p"},"ever_signMessage"),(0,o.kt)("br",{parentName:"p"}),"\n","The predefined list of used function names is placed in Appendix I: Used function names.",(0,o.kt)("br",{parentName:"p"}),"\n","The common recommendation is to restrict access to the EVERSCALE SDK functions that work with private keys and create wrappers with other methods. The user MUST confirm any action that demands interaction with the private keys.",(0,o.kt)("br",{parentName:"p"}),"\n","If an RPC method returns a result without any errors, the code MUST be 4000. If an RPC method returns any  errors as a result, then it SHOULD be rejected with a 4300 error per the Provider Errors section below, or an appropriate error per the RPC method\u2019s specification.",(0,o.kt)("br",{parentName:"p"}),"\n","If an RPC method defined in a finalized TIP is not supported, it SHOULD be rejected with a 4200 error per the Provider Errors section below, or an appropriate error per the RPC method\u2019s specification.  "),(0,o.kt)("h4",{id:"rpc-errors"},"RPC Errors"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"interface ProviderRpcError extends Error {\n  message: string;\n  code: number;\n  data?: unknown;\n}\n")),(0,o.kt)("p",null,"message"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"MUST be a human-readable string"),(0,o.kt)("li",{parentName:"ul"},"SHOULD adhere to the specifications in the Error Standards section below\ncode"),(0,o.kt)("li",{parentName:"ul"},"MUST be an integer number"),(0,o.kt)("li",{parentName:"ul"},"SHOULD adhere to the specifications in the Error Standards section below\ndata"),(0,o.kt)("li",{parentName:"ul"},"SHOULD contain any other useful information about the error")),(0,o.kt)("h4",{id:"error-standards"},"Error Standards"),(0,o.kt)("p",null,"ProviderRpcError codes and messages SHOULD follow these conventions, in order of priority:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"The errors in the Provider Errors section below"),(0,o.kt)("li",{parentName:"ol"},"Any errors mandated by the erroring RPC method\u2019s specification"),(0,o.kt)("li",{parentName:"ol"},"The CloseEvent status codes")),(0,o.kt)("h4",{id:"provider-errors"},"Provider Errors"),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"Status code"),(0,o.kt)("th",{parentName:"tr",align:null},"Name"),(0,o.kt)("th",{parentName:"tr",align:null},"Description"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"4001"),(0,o.kt)("td",{parentName:"tr",align:null},"User Rejected Request"),(0,o.kt)("td",{parentName:"tr",align:null},"The user rejected the request.")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"4100"),(0,o.kt)("td",{parentName:"tr",align:null},"Unauthorized"),(0,o.kt)("td",{parentName:"tr",align:null},"The requested method and/or account has not been authorized by the user.")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"4200"),(0,o.kt)("td",{parentName:"tr",align:null},"Unsupported Method"),(0,o.kt)("td",{parentName:"tr",align:null},"The Provider does not support the requested method.")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"4201"),(0,o.kt)("td",{parentName:"tr",align:null},"Wrong parameters"),(0,o.kt)("td",{parentName:"tr",align:null},"The Provider supports the requested method, but with other parameters.")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"4300"),(0,o.kt)("td",{parentName:"tr",align:null},"Method error"),(0,o.kt)("td",{parentName:"tr",align:null},"The Provider has run the requested method but the result is the error.")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"4900"),(0,o.kt)("td",{parentName:"tr",align:null},"Disconnected"),(0,o.kt)("td",{parentName:"tr",align:null},"The Provider is disconnected from the endpoint.")))),(0,o.kt)("h4",{id:"subscriptions"},"Subscriptions"),(0,o.kt)("p",null,"If the Provider supports EVERSCALE RPC subscriptions, e.g. ",(0,o.kt)("em",{parentName:"p"},"ever_subscribe"),", the Provider MUST emit the message event when it receives a subscription notification.",(0,o.kt)("br",{parentName:"p"}),"\n","If the Provider receives a subscription message from e.g. an ",(0,o.kt)("em",{parentName:"p"},"ever_subscribe")," subscription, the Provider MUST emit a message event with a ProviderMessage object of the following form:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"interface EverscaleSubscription extends ProviderMessage {\n  readonly type: 'ever_subscription';\n  readonly data: {\n    readonly subscription: string;\n    readonly result: unknown;\n  };\n}\n")),(0,o.kt)("h4",{id:"events"},"Events"),(0,o.kt)("p",null,"The Provider MUST implement the following event handling methods:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"on"),(0,o.kt)("li",{parentName:"ul"},"removeListener\nThese methods MUST be implemented per the Node.js EventEmitter API.")),(0,o.kt)("h5",{id:"message"},"message"),(0,o.kt)("p",null,"When emitted, the ",(0,o.kt)("em",{parentName:"p"},"message")," event MUST be emitted with an object argument of the following form:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"interface ProviderMessage {\n  readonly type: string;\n  readonly data: unknown;\n}\n")),(0,o.kt)("h5",{id:"connect"},"connect"),(0,o.kt)("p",null,"If the Provider becomes connected, the Provider MUST emit the event named connect.",(0,o.kt)("br",{parentName:"p"}),"\n","This includes when:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The Provider first connects to an endpoint after initialization."),(0,o.kt)("li",{parentName:"ul"},"The Provider connects to an endpoint after the disconnect event was emitted."),(0,o.kt)("li",{parentName:"ul"},"This event MUST be emitted with an object of the following form:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"interface ProviderConnectInfo {\n  readonly endpoint: string;\n}\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"endpoint MUST specify the URL of the connected endpoint.")),(0,o.kt)("h5",{id:"disconnect"},"disconnect"),(0,o.kt)("p",null,"If the Provider becomes disconnected from the endpoint, the Provider MUST emit the event named disconnect with value error: ProviderRpcError, per the interface defined in the RPC Errors section. The value of the error\u2019s code property MUST follow the status codes for CloseEvent."),(0,o.kt)("h5",{id:"endpointchanged"},"endpointChanged"),(0,o.kt)("p",null,"If the endpoint the connected Provider changes, the Provider MUST emit the event named ",(0,o.kt)("em",{parentName:"p"},"endpointChanged")," with value endpoint: string, specifying theURL of the new endpoint."),(0,o.kt)("h5",{id:"accountchanged"},"accountChanged"),(0,o.kt)("p",null,"If the account is available in the Provider, the Provider MUST emit the event named ",(0,o.kt)("em",{parentName:"p"},"accountChanged")," with value account: string, containing the new account address."),(0,o.kt)("h4",{id:"rationale"},"Rationale"),(0,o.kt)("p",null,"The purpose of a Provider is to provide a consumer with access to EVERSCALE blockchain. In general, a Provider must enable an EVERSCALE web application to do two things:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Make EVERSCALE RPC requests"),(0,o.kt)("li",{parentName:"ul"},"Respond to state changes in the Provider\u2019s EVERSCALE endpoint, Client, and Wallet\nThe Provider API specification consists of a single method and five events. The request method and the message event alone, are sufficient to implement a complete Provider. They are designed to make arbitrary RPC requests and communicate arbitrary messages, respectively.",(0,o.kt)("br",{parentName:"li"}),"The remaining four events can be separated into two categories:"),(0,o.kt)("li",{parentName:"ul"},"Changes to the Provider\u2019s ability to make RPC requests",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"connect"),(0,o.kt)("li",{parentName:"ul"},"disconnect"))),(0,o.kt)("li",{parentName:"ul"},"Common Client and/or Wallet state changes that any non-trivial application must handle",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"endpointChanged"),(0,o.kt)("li",{parentName:"ul"},"accountChanged\nThese events are included due to the widespread production usage of related patterns, at the time of writing.")))),(0,o.kt)("h4",{id:"security-considerations"},"Security Considerations"),(0,o.kt)("p",null,"The Provider is intended to pass messages between a EVERSCALE Client and an EVERSCALE application. It is not responsible for private key or account management; it merely processes RPC messages and emits events. Consequently, account security and user privacy need to be implemented in middlewares between the Provider and its EVERSCALE Client. In practice, we call these middleware applications \u201cWallets,\u201d and they usually manage the user\u2019s private keys and accounts. The Provider can be thought of as an extension of the Wallet, exposed in an untrusted environment, under the control of some third party (e.g. a website)."),(0,o.kt)("h4",{id:"handling-adversarial-behavior"},"Handling Adversarial Behavior"),(0,o.kt)("p",null,"Since it is a JavaScript object, consumers can generally perform arbitrary operations on the Provider, and all its properties can be read or overwritten. Therefore, it is best to treat the Provider object as though it is controlled by an adversary. It is paramount that the Provider implementer protects the user, Wallet, and Client by ensuring that:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The Provider does not contain any private user data."),(0,o.kt)("li",{parentName:"ul"},"The Provider and Wallet programs are isolated from each other."),(0,o.kt)("li",{parentName:"ul"},"The Wallet and/or Client rate-limit requests from the Provider."),(0,o.kt)("li",{parentName:"ul"},"The Wallet and/or Client validate all data sent from the Provider.")),(0,o.kt)("h4",{id:"endpoint-changes"},"Endpoint Changes"),(0,o.kt)("p",null,"Since all EVERSCALE operations are directed at a particular endpoint, it\u2019s important that the Provider accurately reflects the Client\u2019s configured endpoint.",(0,o.kt)("br",{parentName:"p"}),"\n","This includes ensuring that the ",(0,o.kt)("em",{parentName:"p"},"endpointChanged")," event is emitted whenever that value changes."),(0,o.kt)("h4",{id:"user-account-exposure-and-account-changes"},"User Account Exposure and Account Changes"),(0,o.kt)("p",null,"Many EVERSCALE operations (e.g. encode_message) require a user account to be specified. Provider consumers access their own accounts via the ",(0,o.kt)("em",{parentName:"p"},"ever_account")," RPC method, and by listening for the ",(0,o.kt)("em",{parentName:"p"},"accountChanged")," event.",(0,o.kt)("br",{parentName:"p"}),"\n","It is critical that ",(0,o.kt)("em",{parentName:"p"},"ever_account")," has the correct return value, and that the ",(0,o.kt)("em",{parentName:"p"},"accountChanged")," event is emitted whenever that value changes.",(0,o.kt)("br",{parentName:"p"}),"\n","The return value of ",(0,o.kt)("em",{parentName:"p"},"ever_account")," is ultimately controlled by the Wallet or Client. In order to protect user privacy, this document recommends not exposing accounts by default. Instead, Providers SHOULD support RPC methods for explicitly requesting account access, such as ",(0,o.kt)("em",{parentName:"p"},"ever_requestPermissions"),"."),(0,o.kt)("h4",{id:"copyright"},"Copyright"),(0,o.kt)("p",null,"Copyright and related rights waived via ",(0,o.kt)("a",{parentName:"p",href:"https://creativecommons.org/publicdomain/zero/1.0/"},"CC0"),"."),(0,o.kt)("h4",{id:"appendix-i-used-function-names"},"Appendix I: Used function names"),(0,o.kt)("p",null,"As was introduced before in accordingly with the function naming, others, not standard EVERSCALE SDK functions MUST use format ",(0,o.kt)("inlineCode",{parentName:"p"},"prefix_functionName"),", some predefined list of such functions presents below:"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"wallet_getSdkVersion")," - function that SHOULD be used by dApp for getting the SDK version that uses by provider"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"wallet_requestPermissions")," - function that SHOULD be used by dApp for getting the permission from the wallet to work with RPC. The wallet MUST show a popup to get the confirmation from the user on allowing interaction between the wallet and dApp from which the request was received. params for this method is an array with the list of permissions that the user will grant to the dApp. Each permission MUST be a valid RPC method name. All supported by the wallet methods MUST have a description that will allow the user to understand which type of access will be granted. The methods that will contain the potential using of private keys MUST be highlighted."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"wallet_getPermissions")," - function that SHOULD be used by dApp for getting an array of current permissions (empty by default)."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"ever_endpoint")," - function that SHOULD return the current endpoint if the Provider is connected. ",(0,o.kt)("em",{parentName:"p"},"params")," for this method are empty."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"ever_account")," - function that SHOULD return the current account address and public key that is used in the wallet. This method MUST be under the permissions mechanism protection. ",(0,o.kt)("em",{parentName:"p"},"params")," for this method are empty."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"ever_subscribe")," - function that SHOULD be used by dApp for a subscription on blockchain events. Method MUST return subscriptionID that can be used to track the events for this subscription. ",(0,o.kt)("em",{parentName:"p"},"params")," for this method are input arguments for the ever_net_subscribe_collection."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"ever_unsubscribe")," - function that SHOULD be used by dApp for an unsubscription on blockchain events. ",(0,o.kt)("em",{parentName:"p"},"params")," for this method are input arguments for the ",(0,o.kt)("em",{parentName:"p"},"ever_net_unsubscribe"),"."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"ever_sendTransaction")," - function that SHOULD be used by dApp for a sending transaction from wallet to destination with value and message. ",(0,o.kt)("em",{parentName:"p"},"params")," for this method are destination, value, message."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"ever_signMessage")," - function that SHOULD be used by dApp for a receiving signature of data based on the signing box of the current account. ",(0,o.kt)("em",{parentName:"p"},"params")," for this method is a string of unsigned data. This method encapsulates in itself 3 methods - ",(0,o.kt)("em",{parentName:"p"},"get_signing_box"),", ",(0,o.kt)("em",{parentName:"p"},"signing_box"),", ",(0,o.kt)("em",{parentName:"p"},"remove_signing_box")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"ever_getSignature")," - function that SHOULD be used by dApp for a signature getting of a message based on the secret key of the current account. ",(0,o.kt)("em",{parentName:"p"},"params")," for this method is a string of unsigned data. This method uses ",(0,o.kt)("em",{parentName:"p"},"nacl_sign")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"ever_getNaclBoxPublicKey")," - function that SHOULD be used by dApp for getting the public key for nacl box."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"ever_encryptMessage")," - function that SHOULD be used by dApp for a receiving encoded message based on the Receiver's public key and the private key of the current account. ",(0,o.kt)("em",{parentName:"p"},"params")," for this method are input arguments for the ",(0,o.kt)("em",{parentName:"p"},"ever_crypto_nacl_box"),". The public key for a recipient must be got from ",(0,o.kt)("em",{parentName:"p"},"ever_get_nacl_box_public_key")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"ever_decryptMessage")," - function that SHOULD be used by dApp for a receiving encoded message based on the Sender's public key and the private key of the current account. ",(0,o.kt)("em",{parentName:"p"},"params")," for this method are input arguments for the ",(0,o.kt)("em",{parentName:"p"},"ever_crypto_nacl_box_open"),"."),(0,o.kt)("h4",{id:"appendix-ii-consumer-facing-api-documentation"},"Appendix II: Consumer-Facing API Documentation"),(0,o.kt)("h5",{id:"request-1"},"Request"),(0,o.kt)("p",null,"Make a EVERSCALE RPC method call."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"interface RequestArguments {\n  readonly method: string;\n  readonly params?: readonly unknown[] | object;\n}\nProvider.request(args: RequestArguments): Promise<unknown>;\n")),(0,o.kt)("p",null,"The returned Promise resolves with the method\u2019s result or rejects with a ",(0,o.kt)("em",{parentName:"p"},"ProviderRpcError"),". For example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"Provider.request({ method: 'ever_account' })\n  .then((account) => console.log(account))\n  .catch((error) => console.error(error));\n")),(0,o.kt)("p",null,"Consult each EVERSCALE RPC method\u2019s documentation for its params and return type. You can find a list of common methods here."),(0,o.kt)("h5",{id:"events-1"},"Events"),(0,o.kt)("h6",{id:"connect-1"},"connect"),(0,o.kt)("p",null,"The Provider emits ",(0,o.kt)("em",{parentName:"p"},"connect")," when it:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"first connects to an endpoint after being initialized."),(0,o.kt)("li",{parentName:"ul"},"first connects to an endpoint, after the ",(0,o.kt)("em",{parentName:"li"},"disconnect")," event was emitted.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"interface ProviderConnectInfo {\n readonly endpoint: string;\n}\nProvider.on('connect', listener: (connectInfo: ProviderConnectInfo) => void): Provider;\n")),(0,o.kt)("p",null,"The event emits an object with an endpoint URL and other properties as determined by the Provider."),(0,o.kt)("h6",{id:"disconnect-1"},"disconnect"),(0,o.kt)("p",null,"The Provider emits ",(0,o.kt)("em",{parentName:"p"},"disconnect")," when it becomes disconnected from the endpoint."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"Provider.on('disconnect', listener: (error: ProviderRpcError) => void): Provider;\n")),(0,o.kt)("p",null,"This event emits a ProviderRpcError. The error code follows the table of CloseEvent status codes."),(0,o.kt)("h6",{id:"endpointchanged-1"},"endpointChanged"),(0,o.kt)("p",null,"The Provider emits ",(0,o.kt)("em",{parentName:"p"},"endpointChanged")," when connecting to a new endpoint."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"Provider.on('endpointChanged', listener: (endpoint: string) => void): Provider;\n")),(0,o.kt)("p",null,"The event emits a URL string endpoint."),(0,o.kt)("h6",{id:"accountchanged-1"},"accountChanged"),(0,o.kt)("p",null,"The Provider emits ",(0,o.kt)("em",{parentName:"p"},"accountChanged")," if the account returned from the Provider change."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"Provider.on('accountChanged', listener: (account: string) => void): Provider;\n")),(0,o.kt)("p",null,"The event emits an account address."),(0,o.kt)("h6",{id:"unlockstatechanged"},"unlockStateChanged"),(0,o.kt)("p",null,"The Provider emits ",(0,o.kt)("em",{parentName:"p"},"unlockStateChanged")," if the wallet unlock state changes."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"Provider.on('unlockStateChanged', listener: (unlockState: boolean) => void): Provider;\n")),(0,o.kt)("p",null,"The event emits boolean value."),(0,o.kt)("h6",{id:"message-1"},"message"),(0,o.kt)("p",null,"The Provider emits messages to communicate arbitrary messages to the consumer. Messages may include JSON-RPC notifications, GraphQL subscriptions, and/or any other event as defined by the Provider."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"interface ProviderMessage {\n readonly type: string;\n readonly data: unknown;\n}\nProvider.on('message', listener: (message: ProviderMessage) => void): Provider;\n")),(0,o.kt)("h5",{id:"subscriptions-1"},"Subscriptions"),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"ever_subscription")," method relies on this event to emit subscription updates.",(0,o.kt)("br",{parentName:"p"}),"\n","For e.g. ",(0,o.kt)("em",{parentName:"p"},"ever_subscribe")," subscription updates, ProviderMessage.type will equal the string 'ever_subscription', and the subscription data will be the value of ProviderMessage.data."),(0,o.kt)("h5",{id:"errors"},"Errors"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"interface ProviderRpcError extends Error {\n message: string;\n code: number;\n data?: unknown;\n}\n")),(0,o.kt)("h5",{id:"appendix-iii-examples"},"Appendix III: Examples"),(0,o.kt)("p",null,"These examples assume a web browser environment.",(0,o.kt)("br",{parentName:"p"}),"\n","// Most Providers are available as window.ever on page load.",(0,o.kt)("br",{parentName:"p"}),"\n","// This is only a convention, not a standard, and may not be the case in practice.",(0,o.kt)("br",{parentName:"p"}),"\n","// Please consult the Provider implementation's documentation.",(0,o.kt)("br",{parentName:"p"}),"\n","const ever = window.everscale;",(0,o.kt)("br",{parentName:"p"}),"\n","// Example 1: Log endpoint  "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"ever\n  .request({ method: 'ever_endpoint' })\n  .then((endpoint) => {\n    console.log(`URL string: ${endpoint}`);\n  })\n  .catch((error) => {\n    console.error(`Error fetching endpoint: ${error.code}: ${error.message}`);\n  });\n")),(0,o.kt)("p",null,"// Example 2: Query the latest masterchain block height  "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"ever\n  .request({\n    method: 'ever_net_query',\n    params: `query{\n               blocks(filter:{\n                       workchain_id:{\n                         eq:-1\n                       }\n                     }\n                     orderBy:{\n                       path:\"seq_no\"\n                       direction:DESC\n                     }\n                     limit: 1\n                    )\n              {\n                id\n                workchain_id\n                shard\n                seq_no\n              }\n            }`,\n  })\n  .then((block) => {\n    console.log(`Block ${block.number}:`, block);\n  })\n  .catch((error) => {\n    console.error(\n      `Error fetching last block: ${error.message}.\n       Code: ${error.code}. Data: ${error.data}`\n    );\n  });\n")),(0,o.kt)("p",null,"// Example 3: Log available account  "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"ever\n  .request({ method: 'ever_account' })\n  .then((account) => {\n    console.log(`Account:\\n${account.join('\\n')}`);\n  })\n  .catch((error) => {\n    console.error(\n      `Error fetching account: ${error.message}.\n       Code: ${error.code}. Data: ${error.data}`\n    );\n  });\n")),(0,o.kt)("p",null,"// Example 4: Log new events from smart contract  "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"ever\n  .request({\n    method: 'ever_subscribe',\n    params: {\n            collection: \"messages\",\n            filter: {\n              src: {\n                eq: \"-1:67f4bf95722e1bd6df845fca7991e5e7128ce4a6d25f6d4ef027d139a11a7964\",\n              },\n              msg_type:{ eq:2 }\n            },\n            result: \"boc\",\n    }\n  })\n  .then((subscriptionId) => {\n    ever.on('message', (message) => {\n      if (message.type === 'ever_subscription') {\n        const { data } = message;\n        if (data.subscriptionId === subscriptionId) {\n          if ('params' in data && typeof data.params === 'object' && 'result' in data.params && typeof data.params.result === 'object') {\n            const boc = data.params.result.boc;\n            ever\n              .request({\n                method: 'ever_abi_decode_message',\n                params: {\n                  abi: abiContract(HelloEventsContract.abi),\n                  message: boc\n                }\n              }).then((decoded) => {\n                   console.log(`New event ${decoded.name} with type ${decoded.body_type}:`, decoded.value);\n              })\n          } else {\n            console.error(`Something went wrong: ${data.result}`);\n          }\n        }\n      }\n    });\n  })\n  .catch((error) => {\n    console.error(\n      `Error making events subscription: ${error.message}.\n       Code: ${error.code}. Data: ${error.data}`\n    );\n  });\n")),(0,o.kt)("p",null,"// Example 5: Log when account change  "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"const logAccount = (account) => {\n  console.log(`Account:\\n${account}`);\n};\never.on('accountChanged', logAccount);\n// to unsubscribe\never.removeListener('accountChanged', logAccount);\n")),(0,o.kt)("p",null,"// Example 6: Log if connection ends  "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"ever.on('disconnect', (code, reason) => {\n  console.log(`EVERSCALE Provider connection closed: ${reason}. Code: ${code}`);\n});\n")))}m.isMDXComponent=!0}}]);